p8105\_hw1\_ps3070
================

**Problem 1**

First, I will load the tidyverse library.

``` r
library(tidyverse)
```

    ## ── Attaching packages ────────────────────────────────────────────────────────── tidyverse 1.2.1 ──

    ## ✔ ggplot2 3.2.1     ✔ purrr   0.3.2
    ## ✔ tibble  2.1.3     ✔ dplyr   0.8.3
    ## ✔ tidyr   0.8.3     ✔ stringr 1.4.0
    ## ✔ readr   1.3.1     ✔ forcats 0.4.0

    ## ── Conflicts ───────────────────────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()

Next, I will create a dataframe comprised of: \* a random sample of size 8 from a standard Normal distribution \* a logical vector indicating whether elements of the sample are greater than 0 \* a character vector of length 8 \* a factor vector of length 8, with 3 different factor “levels”

First, I set the seed so my results would be reproducible.

``` r
set.seed(123)
```

``` r
prob1_df = tibble(
  random_sample = rnorm(8),
  vec_logical = random_sample > 0, #This creates a logical vector the same length as random_sample with the value True when this condition is satisfied and False when it isn't.
  vec_character = c("abc", "def", "ghi", "jkl", "mno", "pqr", "stu", "vwx"),
  vec_factor = factor(c("p","r","i","p","r","i","p","r"))
)
```

The following code chunk attempts to take the mean of each vector.

``` r
mean(pull(prob1_df, random_sample))
```

    ## [1] 0.2348464

``` r
mean(pull(prob1_df, vec_logical))
```

    ## [1] 0.625

``` r
mean(pull(prob1_df, vec_character))
```

    ## Warning in mean.default(pull(prob1_df, vec_character)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

``` r
mean(pull(prob1_df, vec_factor))
```

    ## Warning in mean.default(pull(prob1_df, vec_factor)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

The mean of `random_sample` and `vec_logical` are possible to compute because they are numeric and logical variables. The logical variable values will be interpreted as `True` = 1 and `False` = 0, so the mean will be an average of these results. The means for vectors `vec_character` and `vec_factor` cannot be computed because, to calculate the mean, R requires the argument to be numeric or logical.

The following code chunk will use `as.numeric()` to try to convert factor, logical, and character variables to numeric.

``` r
fac_to_num = as.numeric(pull(prob1_df, vec_factor))
char_to_num = as.numeric(pull(prob1_df, vec_character))
```

    ## Warning: NAs introduced by coercion

``` r
log_to_num = as.numeric(pull(prob1_df, vec_logical))
```

Factor variables will convert to numeric variables based on the integer values that R assigns to them. Every time a factor vector appears, R will assign the same number to it. Since I created the factor vector with letters, the integers are assigned starting with 1, in alphabetical order.

The logical variable values will be assigned as `True` = 1 and `False` = 0.

R tries to coerce variables of a different type (i.e. not numeric or logical) to NAs. Since the character vector is not based on numbers/integers, we are unable to convert them to numeric. Because of that, I will try to convert the character variable into a factor variable, and then into a numeric variable:

``` r
char_to_num2 = as.numeric(as.factor(pull(prob1_df, vec_character)))
```

Now, the warning message is not received and this produces a string of numbers. Conversion of a character variable to factor and then to numeric was successful.

In the next code chunk, I will:

-   convert the logical vector to numeric, and multiply the random sample by the result
-   convert the logical vector to a factor, and multiply the random sample by the result
-   convert the logical vector to a factor and then convert the result to numeric, and multiply the random sample by the result

``` r
as.numeric(pull(prob1_df, vec_logical)) * pull(prob1_df, random_sample)
as.factor(pull(prob1_df, vec_logical)) * pull(prob1_df, random_sample)
```

    ## Warning in Ops.factor(as.factor(pull(prob1_df, vec_logical)),
    ## pull(prob1_df, : '*' not meaningful for factors

``` r
as.numeric(as.factor(pull(prob1_df, vec_logical))) * pull(prob1_df, random_sample)
```

The first and third operations are successful (logical ot numeric, and logical to factor and tthen numeric. However, when converting the logical vector to a factor variable and then multiplying random sample (numeric) by the result, the console displays a message saying "not meaningful for factors" and displays a string of NAs. Only after converting the factor variable to numeric will R multiply this with a numeric variable.

**Problem 2**

I created a data frame comprised of:

-   x: a random sample of size 500 from a standard Normal distribution
-   y: a random sample of size 500 from a standard Normal distribution
-   A logical vector indicating whether x + y &gt; 1
-   A numeric vector created by coercing the above logical vector
-   A factor vector created by coercing the above logical vector

``` r
set.seed(123)
```

``` r
prob2_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  vec_log = (x + y) > 1,
  vec_num = as.numeric(vec_log),
  vec_fac = as.factor(vec_log)
)
```

The dataset includes 500 rows and 5 columns, indicating that there are 5 vectors with 500 values. The mean of x is 0.0345904. The median of x is 0.0207171. The standard deviation of x is 0.9727694. The proportion of cases for which (x + y) &gt; 1 is the same as the proportion of cases for which the logical vector is 'True', which is 0.228.

Now, I will make a scatterplot of `y` vs `x` using the logical variable `vec_log`, equaling `(x + y) > 1`, as well as the numeric and factor variables created from `vec_log`.

The logical vector `vec_log` and the factor vector `vec_fac` are based on binary values. For the logical vector, values are `True` and `False`, and for the factor vector, values are `0` and `1`. For the numeric vector even though the data values only include `0` and `1`, R will still assume it is continuous. The legends for each plot are created accordingly - for `vec_log` and `vec_fac`, the legends show `FALSE` and `TRUE`, but for `vec_num`, there is a gradient from `0` to `1`, though the plot itself shows only two colors.

``` r
plot_log <- ggplot(prob2_df, aes(x = x, y = y, color = vec_log)) + geom_point(size = 0.5)
plot_num <- ggplot(prob2_df, aes(x = x, y = y, color = vec_num)) + geom_point(size = 0.5)
plot_fac <- ggplot(prob2_df, aes(x = x, y = y, color = vec_fac)) + geom_point(size = 0.5)

plot_log
```

![](p8105_hw1_ps3070_files/figure-markdown_github/create%20scatterplots-1.png)

``` r
plot_num
```

![](p8105_hw1_ps3070_files/figure-markdown_github/create%20scatterplots-2.png)

``` r
plot_fac
```

![](p8105_hw1_ps3070_files/figure-markdown_github/create%20scatterplots-3.png)

``` r
ggsave("plot_log.pdf", height = 4, width = 6)
```
