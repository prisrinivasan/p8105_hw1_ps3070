---
title: "p8105_hw1_ps3070"
output: github_document
---

**Problem 1**

First, I will load the tidyverse library.
```{r adding tidyverse library}
library(tidyverse)
```

Next, I will create a dataframe comprised of:
* a random sample of size 8 from a standard Normal distribution
* a logical vector indicating whether elements of the sample are greater than 0
* a character vector of length 8
* a factor vector of length 8, with 3 different factor “levels”

```{r create vectors}
set.seed(123)
random_sample = rnorm(8)
vec_logical = random_sample > 0 #This creates a logical vector the same length as random_sample with the value True when this condition is satisfied and False when it isn't.
vec_character = c("abc", "def", "ghi", "jkl", "mno", "pqr", "stu", "vwx")
vec_factor = factor(c("p","r","i","p","r","i","p","r"))
```


```{r create dataframe, results="hide"}
prob1_df = tibble(
  random_sample,
  vec_logical,
  vec_character,
  vec_factor
)
```

The following code chunk attempts to take the mean of each vector.
```{r take mean}
mean(random_sample)
mean(vec_logical)
mean(vec_character)
mean(vec_factor)
```

The mean of 'random_sample' and 'vec_logical' are possible to compute because they are numeric and logical variables. The logical variable values will be interpreted as True = 1 and False = 0, so the mean will be an average of these results. The means for vectors 'vec_character' and 'vec_factor' cannot be computed because, to calculate the mean, R requires the argument to be numeric or logical.



The following code chunk will use 'as.numeric' to convert factor, logical, and character variables to numeric.

```{r numeric conversion, results="hide"}
fac_to_num = as.numeric(vec_factor)
char_to_num = as.numeric(vec_character)
log_to_num = as.numeric(vec_logical)
```

Factor variables will convert to numeric variables based on the integer values that R assigns to them. Every time a factor vector appears, R will assign the same number to it. Since I created the factor vector with letters, the integers are assigned starting with 1 and in alphabetical order. 

The logical variable values will be assigned as True = 1 and False = 0.

R tries to coerce variables of a different type (i.e. not numeric or logical) to NAs. Since the character vector is not based on numbers/integers, we are unable to convert to numeric.



In the next code chunk, I will:

* convert the logical vector to numeric, and multiply the random sample by the result
* convert the logical vector to a factor, and multiply the random sample by the result
* convert the logical vector to a factor and then convert the result to numeric, and multiply the random sample by the result

```{r conversions, results="hide"}
as.numeric(vec_logical) * random_sample
as.factor(vec_logical) * random_sample #The console says "not meaningful for factors" and displays a string of NAs because the factor variable I created contained letters.
as.numeric(as.factor(vec_logical)) * random_sample

```


**Problem 2**

I created a data frame comprised of:

* x: a random sample of size 500 from a standard Normal distribution
* y: a random sample of size 500 from a standard Normal distribution
* A logical vector indicating whether x + y > 1
* A numeric vector created by coercing the above logical vector
* A factor vector created by coercing the above logical vector

```{r make vectors}
set.seed(1234)
x = rnorm(500)
y = rnorm(500)
vec_log = (x + y) > 1
vec_num = as.numeric(vec_log)
vec_fac = as.factor(vec_log)
```

```{r create dataframe}
prob2_df = tibble(
  x,
  y,
  vec_log,
  vec_num,
  vec_fac
)
```



The dataset includes `r nrow(prob2_df)` rows and `r ncol(prob2_df)`, indicating that there are 5 vectors with 500 values. The mean of x is `r mean(x)`. The median of x is `r median(x)`. The standard deviation of x is `r sd(x)`. The proportion of cases for which (x + y) > 1 is the same as the proportion of cases for which the logical vector is 'True', which is `r length(which(vec_log))/length(vec_log)`.


